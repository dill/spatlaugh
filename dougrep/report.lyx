#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage[style=authoryear,natbib=true,backend=biber,firstinits=true,uniquename=init]{biblatex} 
\addbibresource{this.bib}
\end_preamble
\use_default_options true
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Provides natbib 1
\end_local_layout
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "ae" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Shortcomings of Horvitz-Thompson-like estimators for large-scale cetacean
 abundance estimation
\end_layout

\begin_layout Author
David L.
 Miller
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

 and Mark V.
 Bravington
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset


\end_layout

\begin_layout Address
\begin_inset script superscript

\begin_layout Plain Layout
1
\end_layout

\end_inset

Integrated Statistics, Woods Hole, MA & Centre for Research into Ecological
 and Environmental Modelling, St
\begin_inset space ~
\end_inset

Andrews, Scotland
\end_layout

\begin_layout Address
\begin_inset script superscript

\begin_layout Plain Layout
2
\end_layout

\end_inset

Commonwealth Scientific and Industrial Research Organization, Hobart, TAS
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<preamble, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

opts_knit$set(cache=TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction 
\end_layout

\begin_layout Standard
A great deal of time and money is spent on large-scale cetacean surveys.
 Though sophisticated statistical methods have been developed to deal with
 the complications of complex spatial data, investigators can opt to perform
 an overly simplistic analysis based on randomisation principles which are
 not appropriate for the data in question.
 An example of a potential issue of this type is the use of 
\begin_inset Quotes eld
\end_inset

vanilla
\begin_inset Quotes erd
\end_inset

 Horvitz-Thompson estimators of abundance from line transect surveys when
 the underlying distribution of the study species varies in space.
 In this paper we show by simulation when such analyses are inappropriate
 in simple situations and reasoning that if an estimator shows poor properties
 in a simple situation, then when the distribution, availability or detectabilit
y is more complex in nature then the estimator will perform even more poorly.
\end_layout

\begin_layout Standard
Here we are interested in two methodologies for estimating abundance from
 line transect distance sampling surveys, one is a design-based estimate,
 the other is a model-based estimate.
 We assume in both cases that the usual assumptions regarding distance sampling
 surveys have been met 
\begin_inset CommandInset citation
LatexCommand citep
before "see e.g.,"
key "Buckland:2001vm,Buckland:2004ts,buckland2015distance"

\end_inset

.
 We also assume that:
\end_layout

\begin_layout Itemize
Distances are recorded for each observation (along with the size of each
 group of animals, without error)
\end_layout

\begin_layout Itemize
The vessel's location along the transect is recorded during the survey (for
 example using an automated waypoint function on a GPS unit), i.e., the transect
 lines are recorded as they were visited (the 
\shape italic
realised design
\shape default
), rather than as they were designed.
\end_layout

\begin_layout Itemize
A covariate that gives some indication of sighting conditions was also recorded
 (we simply refer to this as 
\begin_inset Quotes eld
\end_inset

weather
\begin_inset Quotes erd
\end_inset

 but it could be Beaufort Sea State or some other omnibus measure of visual
 conditions).
\end_layout

\begin_layout Standard
We now describe the two ways in which one could analyse this data, as used
 below.
\end_layout

\begin_layout Section
Methods
\end_layout

\begin_layout Standard
We do not spend time here describing fitting the detection function to the
 distance data and refer readers to 
\begin_inset CommandInset citation
LatexCommand citet
key "Buckland:2001vm,Buckland:2004jq,buckland2015distance"

\end_inset

 for information on model formulation and selection.
 Assuming a fitted detection function (which we will denote 
\begin_inset Formula $\hat{g}$
\end_inset

, a function of distance, observed detection-related covariates and estimated
 parameters), we can estimate the average (over distance) probability of
 detection for an individual (conditional on observed covariate values),
 
\begin_inset Formula $\hat{p}_{i}$
\end_inset

, by integrating out distance for a given observation 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Subsection
Horvitz-Thompson-like estimators
\end_layout

\begin_layout Standard
We first describe the 
\begin_inset Quotes eld
\end_inset

Horvitz-Thompson-like
\begin_inset Quotes erd
\end_inset

 estimator (henceforth HT) 
\begin_inset CommandInset citation
LatexCommand citep
before "e.g.,"
key "Borchers:2004wr"

\end_inset

.
 In its simplest version, the HT estimator is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{N}_{HT}=\frac{A}{a}\sum_{i=1}^{n}\frac{s_{i}}{\hat{p}_{i}}\label{eq:HT}
\end{equation}

\end_inset

where 
\begin_inset Formula $n$
\end_inset

 is the number of observations, index by 
\begin_inset Formula $i$
\end_inset

, 
\begin_inset Formula $s_{i}$
\end_inset

 is the size of the 
\begin_inset Formula $i^{\text{th}}$
\end_inset

 group and 
\begin_inset Formula $\hat{p}_{i}$
\end_inset

 is the detectability estimated for the 
\begin_inset Formula $i^{\text{th}}$
\end_inset

 group, which will be a function of the covariates for that observation.
 The total area surveyed (
\shape italic
covered area
\shape default
) is 
\begin_inset Formula $a$
\end_inset

, which is the product of the line lengths and their corresponding strip
 widths (if the strips were all the same width then 
\begin_inset Formula $a=2wL$
\end_inset

, where 
\begin_inset Formula $w$
\end_inset

 is the strip half-width as in Buckland et al 2001, and 
\begin_inset Formula $L$
\end_inset

 is the sum of all the lines' lengths).
 Finally, 
\begin_inset Formula $A$
\end_inset

 is the area that we wish to estimate abundance for (sometimes referred
 to as the 
\shape italic
study area
\shape default
).
 Intuitively, we take the group sizes, correct them for detectability and
 sum to get an estimate of abundance in the covered area, we then rescale
 this to the study region.
 The HT estimator assumes that animal density is constant within the study
 area.
 This assumption may be justifiable in some situations, but seems very unlikely
 in a dynamic environment such as an ocean.
\end_layout

\begin_layout Standard
In order to circumvent this shortcoming, we can perform pre or post hoc
 stratification, slicing-up the study area into smaller subsets and estimating
 abundance for each of these.
 These may be geographically defined (
\begin_inset Quotes eld
\end_inset

near vs.
 far from shore
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

east/west of some longitude
\begin_inset Quotes erd
\end_inset

, etc), based on conditions at sea (
\begin_inset Quotes eld
\end_inset

dense vs.
 non-dense ice
\begin_inset Quotes erd
\end_inset

) or based on oceanographic features (
\begin_inset Quotes eld
\end_inset

deep or shallow water
\begin_inset Quotes erd
\end_inset

).
 Mathematically, this consists of changing the limits of the sum (summing
 over the animals which occur at a given depth or in a particular area etc),
 then changing 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $A$
\end_inset

 accordingly to reflect the effort in the given stratum and the area of
 that stratum, respectively; abundance estimates can then be summed to obtain
 total abundance or given per-stratum form.
 In some sense these estimates reflect a crude, 
\begin_inset Quotes eld
\end_inset

blocky
\begin_inset Quotes erd
\end_inset

 spatial model, which try to address the deeper drivers of distribution
 in a given species.
 Stratification can be performed using animal/group-specific covariates
 (e.g., abundance of males/females, juveniles/adults etc), though we do not
 address this here.
\end_layout

\begin_layout Standard
Variance is estimated for 
\begin_inset Formula $\hat{N}_{HT}$
\end_inset

 by noting that there are two sources of randomness in the equation: 
\shape italic
(i) 
\shape default
from the variance in the model for 
\begin_inset Formula $\hat{p}_{i}$
\end_inset

 and 
\shape italic
(ii)
\shape default
 from the randomness in the number of observed groups, 
\begin_inset Formula $n$
\end_inset

.
 The variance component from 
\begin_inset Formula $\hat{p}_{i}$
\end_inset

 can be calculated by using the variance from the detection function estimation
 procedure and using a sandwich estimator to express that parameter variance
 on the scale of 
\begin_inset Formula $\hat{p}_{i}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "Appendix C"
key "Borchers:2002vs"

\end_inset

.
 Variance in 
\begin_inset Formula $n$
\end_inset

 is usually calculated as variance in 
\begin_inset Formula $n/L$
\end_inset

, that is the encounter rate variance.
 There are a number of options for this estimator, depending on the possible
 design used.
 
\begin_inset CommandInset citation
LatexCommand citet
key "Fewster:2009ku"

\end_inset

 proposes a series of estimators and evaluates them.
 Here we use the 
\begin_inset CommandInset citation
LatexCommand citet
key "Fewster:2009ku"

\end_inset

 R2 estimator (though the encounter rate estimator itself is 
\begin_inset Formula $\hat{N}/L$
\end_inset

, see 
\begin_inset CommandInset citation
LatexCommand citealp
key "Innes:2002ka"

\end_inset

).
\end_layout

\begin_layout Subsection
Density surface models
\end_layout

\begin_layout Standard
We now describe one spatially explicit approach to modelling distance sampling
 line transect survey data, which we refer to as 
\shape italic
density surface models
\shape default
 
\begin_inset CommandInset citation
LatexCommand citep
before "DSMs;"
key "Hedley:2004et,Miller:2013fq"

\end_inset

.
 These are similar to the HT estimators above, as they assume that the detection
 function has already been adequately fitted to the distance data and estimates
 of probability of detection are available for the spatial model to use.
 The spatial part of the model uses the generalized additive modelling framework
 
\begin_inset CommandInset citation
LatexCommand citep
key "hastie1990generalized,Ruppert:2003uc,Wood:2006vg"

\end_inset

 to build smooth, spatially explicit terms describing the distribution of
 the species and their response to other biological/physical variables (though
 in this paper we only consider models that include smooths of location).
 Rather than dealing with whole transects (which are generally long and
 can include large changes in animal density along their length, as well
 as covariate values), we cut the transects into smaller pieces, which we
 call 
\shape italic
segments
\shape default
.
 The mean response of the model can be written as:
\begin_inset Formula 
\[
\mathbb{E}(n_{j})=A_{j}\hat{p}_{j}\exp(\beta_{0}+\sum_{k}s_{k}(z_{kj})),
\]

\end_inset

where 
\begin_inset Formula $j$
\end_inset

 indexes the segments, each of which have area 
\begin_inset Formula $A_{j}$
\end_inset

 and all observations in that segment have a probability of detection of
 
\begin_inset Formula $\hat{p}_{j}$
\end_inset

.
 The response, 
\begin_inset Formula $n_{j}$
\end_inset

, is distributed according to some count distribution for which 
\begin_inset Formula $\exp$
\end_inset

 is the inverse link function
\begin_inset Foot
status open

\begin_layout Plain Layout
Though any exponential family response can be used in the GAM framework
 with any appropriate link function, we just talk about count distributions
 and log link functions for clarity of notation.
\end_layout

\end_inset

.
 The model intercept is 
\begin_inset Formula $\beta_{0}$
\end_inset

.
 The 
\begin_inset Formula $s_{k}$
\end_inset

 are usually splines 
\begin_inset CommandInset citation
LatexCommand citep
key "deBoor:1978wq"

\end_inset

: smooth functions of one or more covariates (denoted 
\begin_inset Formula $z_{jk}$
\end_inset

), though could be more exotic things like random effects, tensor products,
 smooth-factor interactions and so forth 
\begin_inset CommandInset citation
LatexCommand citep
key "Wood:2016cw"

\end_inset

.
 The exact form of each 
\begin_inset Formula $s_{k}$
\end_inset

 depends on the nature of the effect we wish to model, for smooths of location
 there are quite a few options, some of which are enumerated and described
 below.
\end_layout

\begin_layout Standard
A typical DSM may take a form such as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\mathbb{E}(n_{j})=A_{j}\hat{p}_{j}\exp(\beta_{0}+s_{x,y}(x_{j},y_{j})+s_{\text{Depth}}(\text{Depth}_{j})),
\]

\end_inset

that is: the expected count in segment 
\begin_inset Formula $j$
\end_inset

 is a function of its location and the water depth at that location, this
 is then exponentiated onto the response scale, and multiplied by the area
 of the segment and probability of detection in that segment.
\end_layout

\begin_layout Standard
Note that here the probability of detection has a subscript 
\begin_inset Formula $j$
\end_inset

 not 
\begin_inset Formula $i$
\end_inset

 as in the HT estimator.
 This is because in this formulation of the DSM we only consider detectability
 as varying at the scale of the segments, not the observed individuals/groups.
 This means that covariates that effect detectability such as weather, observer
 shift or ship can be used, but sex of the animal or observer ID (if there
 were multiple observers on deck at once) cannot be
\begin_inset Foot
status open

\begin_layout Plain Layout
These covariates can be included in a more general formulation of DSMs,
 though we don't consider them here for clarity of presentation.
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Motivation
\end_layout

\begin_layout Standard
A criticism of the DSM approach is that it is more complex, as we explicitly
 model the spatial and environmental covariate effects, but this explicit
 modelling is the only way to deal with the heterogeneity in spatial distributio
n of the study species.
 We note that an appeal to 
\begin_inset Quotes eld
\end_inset

pooling robustness
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citep
after "Section 11.12"
key "Buckland:2004ts"

\end_inset

 does not get around this issue.
 Before explaining why, we first define and explain pooling robustness in
 a distance sampling context.

\shape italic
 
\shape default
From 
\begin_inset CommandInset citation
LatexCommand citet
key "Burnham:1980wz"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
n\hat{f}(0)=\sum_{r=1}^{R}n_{r}\hat{f}_{r}(0)
\]

\end_inset

where there are 
\begin_inset Formula $R$
\end_inset

 strata chosen to minimise heterogeneity, 
\begin_inset Formula $n$
\end_inset

 is the total number of observations, 
\begin_inset Formula $n_{r}$
\end_inset

 is the number of observations in stratum 
\begin_inset Formula $j$
\end_inset

 and 
\begin_inset Formula $\hat{f}(0)$
\end_inset

 and 
\begin_inset Formula $\hat{f}_{r}(0)$
\end_inset

 are the probability density functions of the observed distances, evaluated
 at zero distance, for the whole sample and by stratum, respectively.
 Equivalently we can write:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{n}{\hat{p}}=\sum_{r=1}^{R}\frac{n_{r}}{\hat{p}_{r}}.
\]

\end_inset


\end_layout

\begin_layout Standard
Intuitively, we say that pooling robustness holds, the estimates from a
 stratified analysis would be the same as those for an unstratified analysis.
 
\begin_inset CommandInset citation
LatexCommand citep
after "Section 11.12"
key "Buckland:2004ts"

\end_inset

 state: 
\begin_inset Quotes eld
\end_inset

if only an overall abundance estimate is required, standard methods without
 covariates are satisfactory under rather mild conditions, provided heterogeneit
y in detectability is not too extreme.
\begin_inset Quotes erd
\end_inset

 This is a statement about HT estimation in the presence of detection heterogene
ity and does not say anything about the case where density varies within
 strata — in this case the effect of detectability and distribution are
 confounded, unless data on observation conditions (e.g., a weather covariate)
 and spatial distribution (e.g., location of transects) is recorded and modelled.
 A spatial model that includes data on the location of the observations
 and the sighting conditions will be able to tease apart these effects and
 attribute appropriate uncertainty.
\end_layout

\begin_layout Standard
So far we have only considered the case where detectability is certain on
 the line (
\begin_inset Formula $g(0)=1$
\end_inset

).
 If we start to consider issues around uncertain detectability on the line
 
\begin_inset CommandInset citation
LatexCommand citep
key "Borchers:1998eq,Borchers:1998ic,Borchers:2005do,Burt:2014gu"

\end_inset

 this situation only gets more complicated.
 
\begin_inset CommandInset citation
LatexCommand citet
key "Buckland:2004ts"

\end_inset

 say: 
\begin_inset Quotes eld
\end_inset

If 
\begin_inset Formula $g(0,z)$
\end_inset

 is a function of 
\begin_inset Formula $z$
\end_inset

, then the model robustness criterion fails, and we must model the heterogeneity
 to avoid bias
\begin_inset Quotes erd
\end_inset

, so if we do expect that the probability of detection at zero distance
 is influenced by covariates (which it almost surely will be), pooling robustnes
s does not apply.
\end_layout

\begin_layout Standard
Pooling robustness is implicitly conditioned on having a 
\begin_inset Quotes eld
\end_inset

reasonable
\begin_inset Quotes erd
\end_inset

 design, so appeals to it should only be made in the case where the realised
 design has (approximately) even coverage.
\end_layout

\begin_layout Standard
Given the above, there is a temptation then to fit a 
\begin_inset Quotes eld
\end_inset

dumb
\begin_inset Quotes erd
\end_inset

 spatial model and hope for the best.
 Properly configuring a spatial model is a time-consuming process requiring
 some 
\begin_inset Quotes eld
\end_inset

expert
\begin_inset Quotes erd
\end_inset

 judgement.
 As well as formulating, fitting and selecting between models, the investigator
 also needs to select an appropriate prediction grid, ensuring that unreasonable
 extrapolations are not made.
 There is no 
\begin_inset Quotes eld
\end_inset

quick fix
\begin_inset Quotes erd
\end_inset

 to obtain a good spatial model, care must be taken in the construction
 and checking of the model if reasonable inferences are to be drawn.
\end_layout

\begin_layout Section
Simulation setup
\end_layout

\begin_layout Standard
With the above in mind, we set about constructing some simple simulations
 of plausible survey data.
 We attempted to keep the underlying densities as simple as possible and
 the realised designs as fairly realistic.
\end_layout

\begin_layout Subsection
Density surfaces
\begin_inset CommandInset label
LatexCommand label
name "subsec:Density-surfaces"

\end_inset


\end_layout

\begin_layout Standard
We used a series of simple density surfaces to test for differences between
 the proposed models.
 Although animal distribution is much more complicated than the patterns
 shown below, if models fail for these simple density surfaces (where gradients
 are clearly defined) then it's likely that there will be more severe issues
 when more complex surfaces are used.
 In the simulations presented here the following surfaces were investigated:
\end_layout

\begin_layout Itemize
“f”: flat density, uniform distribution across the region.
 
\end_layout

\begin_layout Itemize
“lr”: left to right gradient, high on the left, decreasing as we go right.
 
\end_layout

\begin_layout Itemize
“rl”: right to left gradient, high on the right, decreasing as we go left.
 
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

diag
\begin_inset Quotes erd
\end_inset

: increasing gradient from top right to bottom left
\end_layout

\begin_layout Standard
These are shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:densities"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<densities, fig.width=9, fig.height=3, echo=FALSE, message=FALSE, warning=FALSE>>
=
\end_layout

\begin_layout Plain Layout

library(viridis)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

par(mfrow=c(1,4))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# first 3
\end_layout

\begin_layout Plain Layout

n_grid_x <- 300
\end_layout

\begin_layout Plain Layout

n_grid_y <- 100
\end_layout

\begin_layout Plain Layout

density.surface <- expand.grid(x = seq(0, 3, len=n_grid_x),
\end_layout

\begin_layout Plain Layout

                               y = seq(0, 1, len=n_grid_y))
\end_layout

\begin_layout Plain Layout

densities <- list(rep(1, length(density.surface$x)),
\end_layout

\begin_layout Plain Layout

			      rev(density.surface$x),
\end_layout

\begin_layout Plain Layout

				  density.surface$x,
\end_layout

\begin_layout Plain Layout

				  rev(density.surface$x),
\end_layout

\begin_layout Plain Layout

				  rev(density.surface$x)) 
\end_layout

\begin_layout Plain Layout

names <- list("f", "lr", "rl")    
\end_layout

\begin_layout Plain Layout

for(i in 1:3){   
\end_layout

\begin_layout Plain Layout

  image(matrix(densities[[i]], n_grid_x, n_grid_y),
\end_layout

\begin_layout Plain Layout

        x=seq(0, 3, len=n_grid_x),
\end_layout

\begin_layout Plain Layout

        y= seq(0, 1, len=n_grid_y),
\end_layout

\begin_layout Plain Layout

        col = viridis(1000), main=names[[i]],
\end_layout

\begin_layout Plain Layout

        xlab="x", ylab="y", asp=1)
\end_layout

\begin_layout Plain Layout

  contour(matrix(densities[[i]], n_grid_x, n_grid_y),
\end_layout

\begin_layout Plain Layout

        x=seq(0, 3, len=n_grid_x),
\end_layout

\begin_layout Plain Layout

        y= seq(0, 1, len=n_grid_y),
\end_layout

\begin_layout Plain Layout

        add=TRUE)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# one of these densities is not like the other...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n_grid_y <- 300
\end_layout

\begin_layout Plain Layout

n_grid_x <- 300
\end_layout

\begin_layout Plain Layout

density.surface <- expand.grid(x = seq(0, 3, len=n_grid_x),
\end_layout

\begin_layout Plain Layout

                               y = seq(0, 3, len=n_grid_y))
\end_layout

\begin_layout Plain Layout

ddens <- 5*(rev(density.surface$x)*rev(density.surface$y))
\end_layout

\begin_layout Plain Layout

image(matrix(ddens, n_grid_x, n_grid_y),
\end_layout

\begin_layout Plain Layout

      x=seq(0, 3, len=n_grid_x),
\end_layout

\begin_layout Plain Layout

      y= seq(0, 3, len=n_grid_y),
\end_layout

\begin_layout Plain Layout

      col = viridis(1000), main="diag",
\end_layout

\begin_layout Plain Layout

      xlab="x", ylab="y", asp=1)
\end_layout

\begin_layout Plain Layout

contour(matrix(ddens, n_grid_x, n_grid_y),
\end_layout

\begin_layout Plain Layout

        x=seq(0, 3, len=n_grid_x),
\end_layout

\begin_layout Plain Layout

        y= seq(0, 3, len=n_grid_y),
\end_layout

\begin_layout Plain Layout

        add=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The proposed density surfaces.
 From left to right: flat, left-right gradient, right-left gradient, diagonal
 gradient.
\begin_inset CommandInset label
LatexCommand label
name "fig:densities"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Detectability
\end_layout

\begin_layout Standard
Detectability in the survey was set at two fixed detectabilities 
\begin_inset Quotes eld
\end_inset

high
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

low
\begin_inset Quotes erd
\end_inset

 by varying the parameters of a hazard rate detection function.
 We also simulated a two-level weather covariate that changed from left
 to right across the study area, on one side the weather was 
\begin_inset Quotes eld
\end_inset

good
\begin_inset Quotes erd
\end_inset

 (characterised by detection function 1, below) and on the other side the
 weather was 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 (characterised by detection function 2).
 The transition was controlled by a logistic function.
 
\end_layout

\begin_layout Standard
Plots of the detection functions used to simulate the data are shown in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:dfs"

\end_inset

 and a table of the parameters of the detection functions is given in Table
 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:df-pars"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Detection function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Scale
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Shape
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Truncation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.025
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.005
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Parameters for the detection functions used in the simulations.
 Plots of the detection functions are shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:dfs"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:df-pars"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<detfct, fig.width=10, fig.height=4, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

par(mfrow=c(1,2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# parameters
\end_layout

\begin_layout Plain Layout

df_good <- list(key        = "hr",
\end_layout

\begin_layout Plain Layout

                scale      = 0.025,
\end_layout

\begin_layout Plain Layout

                shape      = 3,
\end_layout

\begin_layout Plain Layout

                truncation = 0.05) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df_bad <- list(key        = "hr",
\end_layout

\begin_layout Plain Layout

                    scale      = 0.005,
\end_layout

\begin_layout Plain Layout

                    shape      = 1,
\end_layout

\begin_layout Plain Layout

                    truncation = 0.05)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# plotter
\end_layout

\begin_layout Plain Layout

plot_df <- function(df){
\end_layout

\begin_layout Plain Layout

  distance <- seq(0, 0.06, len=1000)
\end_layout

\begin_layout Plain Layout

  f <- 1 - exp( - (distance/df$scale)^( - df$shape))
\end_layout

\begin_layout Plain Layout

  plot(distance, f, type="l", ylim=c(0,1),
\end_layout

\begin_layout Plain Layout

       xlab="Distance", ylab="Probability of detection")
\end_layout

\begin_layout Plain Layout

  abline(v=df$truncation, lty=2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# actually make some plots
\end_layout

\begin_layout Plain Layout

plot_df(df_good)
\end_layout

\begin_layout Plain Layout

plot_df(df_bad)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Detection functions used in the simulations.
 Dashed line indicates the truncation distance used.
 Left to right have the parameters given top to bottom in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:df-pars"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "fig:dfs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We do not consider the case where detectability is uncertain at zero distance
 (
\begin_inset Formula $g(0)\neq1$
\end_inset

) here.
 We assume that if animals occur directly in front of the observer they
 will be seen.
 We also do not consider any availability issues (that whales are often
 underwater and cannot be seen).
 Finally, we also assume that observations are of single animals (that group
 size is one).
 These are simplifying assumptions, but a modelling strategy that fails
 in this simple situation is unlikely to perform well once any of these
 assumptions are relaxed.
\end_layout

\begin_layout Subsection
Designs
\end_layout

\begin_layout Standard
We experimented with four designs.
 Two 
\begin_inset Quotes eld
\end_inset

iffy
\begin_inset Quotes erd
\end_inset

 designs: one with a large gap between each contiguous section of realised
 effort and one with two very different effort distributions for two parts
 of the survey.
 A 
\begin_inset Quotes eld
\end_inset

bad
\begin_inset Quotes erd
\end_inset

 design where the effort is concentrated along two sides of the area.
 A good design with good realised coverage across the whole study area (to
 confirm that what we consider to be a good design gives us the results
 we expect from our metrics).
 The designs are shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:designs"

\end_inset

.
 In each case the box surrounding the design indicates the area used for
 prediction in the simulations, dashed lines indicate strata used for stratified
 HT estimates.
\end_layout

\begin_layout Subsubsection*
Design 1: zig-zag with straight line
\end_layout

\begin_layout Standard
This is supposed to mimic the situation in which a zig-zag design went well
 on the left side of the study area, but not realised in the middle of the
 survey (perhaps due to bad weather), then to the left we have a lonely
 transect (perhaps weather picked-up).
 Shown in the left panel of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:designs"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Design 2: two different zig-zags
\end_layout

\begin_layout Subsubsection*
Design 2: corner
\end_layout

\begin_layout Standard
This design concentrates along two sides of the study area, this design
 mimics the commonly used technique where near-coast transects are used
 to extrapolate well beyond the covered area.
 Shown in the third panel of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:designs"

\end_inset

.
\end_layout

\begin_layout Subsubsection*
Design 3: zig-zag with good coverage
\end_layout

\begin_layout Standard
The final design has good coverage over the whole study area and would be
 the ideal realised design.
 Shown in the right panel of Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:designs"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<designs, echo=FALSE, fig.width=11, fig.height=4>>=
\end_layout

\begin_layout Plain Layout

par(mfrow=c(1,4))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# function to make the plots
\end_layout

\begin_layout Plain Layout

plot_shape <- function(shape, main, strat=NULL, xlim=c(0,3), ylim=c(0,1)){
\end_layout

\begin_layout Plain Layout

  plot(xlim, ylim, type="n", xlab="x", ylab="y", asp=1, main=main) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  for(i in unique(shape$leg)){ 
\end_layout

\begin_layout Plain Layout

    lines(shape[,c("x","y")][shape$leg==i,]) 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  lines(c(xlim[1], xlim[2], xlim[2], xlim[1], xlim[1]),
\end_layout

\begin_layout Plain Layout

        c(ylim[1], ylim[1], ylim[2], ylim[2], ylim[1]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(!is.null(strat)){
\end_layout

\begin_layout Plain Layout

    for(i in 1:length(strat)){
\end_layout

\begin_layout Plain Layout

      lines(x=rep(strat[i], 2), y=ylim, lty=2, col="red")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# make a zig (or is it a zag?)
\end_layout

\begin_layout Plain Layout

n_segs <- 10
\end_layout

\begin_layout Plain Layout

zz <- data.frame(x = c(seq(0, 0.5, len=n_segs), seq(0.5, 1, len=n_segs)),
\end_layout

\begin_layout Plain Layout

                 y = c(seq(0, 1, len=n_segs), seq(1, 0, len=n_segs)), 
\end_layout

\begin_layout Plain Layout

                 leg = c(rep("1", n_segs), rep("2", n_segs)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# many zigzags
\end_layout

\begin_layout Plain Layout

mzz <- rbind(zz,zz,zz)
\end_layout

\begin_layout Plain Layout

mzz$x <- mzz$x/3 
\end_layout

\begin_layout Plain Layout

ind <- 1:nrow(zz) 
\end_layout

\begin_layout Plain Layout

mzz$x[ind+nrow(zz)] <- mzz$x[ind+nrow(zz)]+1/3 
\end_layout

\begin_layout Plain Layout

mzz$x[ind+2*nrow(zz)] <- mzz$x[ind+2*nrow(zz)]+2/3
\end_layout

\begin_layout Plain Layout

mzz$leg <- as.numeric(mzz$leg) 
\end_layout

\begin_layout Plain Layout

mzz$leg[ind+nrow(zz)] <- mzz$leg[ind+nrow(zz)]+2 
\end_layout

\begin_layout Plain Layout

mzz$leg[ind+2*nrow(zz)] <- mzz$leg[ind+2*nrow(zz)]+4 
\end_layout

\begin_layout Plain Layout

mzz$leg <- as.character(mzz$leg)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mzz2 <- mzz
\end_layout

\begin_layout Plain Layout

mzz2$x <- mzz$x*3
\end_layout

\begin_layout Plain Layout

strat_mzz <- c(1,2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# zig zag then line
\end_layout

\begin_layout Plain Layout

zzl <- rbind.data.frame(mzz, 
\end_layout

\begin_layout Plain Layout

                        data.frame(x = rep(2.8, 10), 
\end_layout

\begin_layout Plain Layout

                                   y = seq(0, 1, len=10), 
\end_layout

\begin_layout Plain Layout

                                   leg = rep(as.character(max(as.numeric(mzz$leg))
+1), 10)))
\end_layout

\begin_layout Plain Layout

strat_zzl <- 1.5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

### now the corner
\end_layout

\begin_layout Plain Layout

region_sq <- data.frame(x=c(0,0,3,3,0),
\end_layout

\begin_layout Plain Layout

                        y=c(0,3,3,0,0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n_segs <- 3
\end_layout

\begin_layout Plain Layout

zz <- data.frame(y = c(seq(0, 0.25, len=n_segs),
\end_layout

\begin_layout Plain Layout

                       seq(0.25, 0.5, len=n_segs)),
\end_layout

\begin_layout Plain Layout

                 x = c(seq(0, 0.5, len=n_segs),
\end_layout

\begin_layout Plain Layout

                       seq(0.5, 0, len=n_segs)))
\end_layout

\begin_layout Plain Layout

mzz <- rbind(zz, zz, zz, zz, zz)
\end_layout

\begin_layout Plain Layout

mzz$y <- mzz$y + sort(rep(seq(0.5,2.5, by=0.5), 2*n_segs))
\end_layout

\begin_layout Plain Layout

mzz$leg <- sort(rep(seq(1,10, by=1), 3))
\end_layout

\begin_layout Plain Layout

mzz$x <- mzz$x +0.25
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

zzu <- data.frame(x = c(seq(0, 0.25, len=n_segs),
\end_layout

\begin_layout Plain Layout

                        seq(0.25, 0.5, len=n_segs)),
\end_layout

\begin_layout Plain Layout

                  y = c(seq(0.5, 0, len=n_segs),
\end_layout

\begin_layout Plain Layout

                        seq(0, 0.5, len=n_segs)))
\end_layout

\begin_layout Plain Layout

mzzu <- rbind(zzu, zzu, zzu, zzu, zzu)
\end_layout

\begin_layout Plain Layout

mzzu$x <- mzzu$x + sort(rep(seq(0.25,2.25, by=0.5), 2*n_segs))
\end_layout

\begin_layout Plain Layout

mzzu$leg <- 10+sort(rep(seq(1,10, by=1), 3))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

corner <- rbind.data.frame(mzz, mzzu)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# make the plots
\end_layout

\begin_layout Plain Layout

plot_shape(mzz2, "good", strat_mzz)
\end_layout

\begin_layout Plain Layout

plot_shape(zzl, "iffy", strat_zzl)
\end_layout

\begin_layout Plain Layout

plot_shape(corner, "bad", 1, xlim=c(0,3), ylim=c(0,3))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Realised effort for the designs used in the simulations.
 From left to right: the bad design, with most of the effort on the left
 of the design; the 
\begin_inset Quotes eld
\end_inset

iffy
\begin_inset Quotes erd
\end_inset

 design where effort is more sporadically allocated; the good design with
 even coverage.
 In each case the black box around the designs indicates the limits of the
 study area.
 Red dashed lines indicate the boundaries of the strata used with the stratified
 HT estimator (see 
\begin_inset Quotes eld
\end_inset

Models
\begin_inset Quotes erd
\end_inset

).
\begin_inset CommandInset label
LatexCommand label
name "fig:designs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Models
\end_layout

\begin_layout Standard
Both spatially explicit models and HT methods were used to estimate abundance
 for each simulation.
 These are enumerated below.
 Since we only include spatial terms in our simulations and we believe that
 in general our spatial effects can be estimated by bivariate smooths (even
 if in this example the underlying densities are better suited to univariate
 smooths, we never know this 
\shape italic
a priori
\shape default
).
 The spatial models are separated into two classes: those which have the
 isotropy property (that a unit change in one direction is considered to
 be equivalent to a unit change in an orthogonal direction, sometimes referred
 to as 
\shape italic
rotational invariance
\shape default
) and those which do not; these are constructed by a 
\shape italic
tensor product
\shape default
 of univariate splines.
 We also test that the setup of the smoother isn't unduly advantageous to
 a particular model by rotating the coordinates system by 45º using the
 rotation matrix: 
\begin_inset Formula 
\[
R=\begin{pmatrix}cos(\pi/4) & -sin(\pi/4)\\
sin(\pi/4) & cos(\pi/4)
\end{pmatrix}
\]

\end_inset


\end_layout

\begin_layout Itemize
Isotropic smooths 
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Thin plate spline
\family typewriter
, bs="tp"
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Wood:2003tc"

\end_inset


\end_layout

\begin_layout Itemize
Thin plate spline with shrinkage, 
\family typewriter
bs="ts"
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Marra:2011fv"

\end_inset


\end_layout

\begin_layout Itemize
Duchon spline, 
\family typewriter
bs="ds", m=c(1, 0.5)
\family default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Miller:2014hc"

\end_inset


\end_layout

\begin_layout Itemize
Thin plate spline with rotated covariates, 
\family typewriter
bs="tp"
\end_layout

\end_deeper
\begin_layout Itemize
Tensor product smooths (smooths listed below were used in both directions)
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Thin plate spline, 
\family typewriter
bs="tp"
\family default
 
\end_layout

\begin_layout Itemize
Thin plate spline with rotated covariates, 
\family typewriter
bs="tp"
\end_layout

\end_deeper
\begin_layout Itemize
Non-spatially explicit models
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Horvitz-Thompson (assuming one stratum, using 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:HT"

\end_inset

)
\end_layout

\begin_layout Itemize
stratified Horvitz-Thompson using strata as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:designs"

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Note that for the detection function part of each model we fit a model of
 the same form as the generating model, we do not consider model uncertainty
 or selection for the detection function.
\end_layout

\begin_layout Subsection
Software
\end_layout

\begin_layout Standard
All simulations were generated using 
\family typewriter
DSsim
\family default
 (R package version 1.0.4), with a wrapper scripts used to generate data that
 could be easily analysed.
 Detection functions were fitted in 
\family typewriter
Distance
\family default
 (R package version 0.9.6) and spatial models were fitted using
\family typewriter
 dsm
\family default
 (R package version 2.2.12).
 Code for the simulations and this paper is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://github.com/dill/spatlaugh
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Metrics
\end_layout

\begin_layout Standard
In order to assess the performance of the abundance estimates, we use two
 graphical methods.
\end_layout

\begin_layout Subsubsection
Bias
\end_layout

\begin_layout Standard
We can simply calculate the bias (
\begin_inset Formula $N_{\text{truth}}-\hat{N}$
\end_inset

) and plot boxplots of these values, however this does not get to the uncertaint
y, which we're more interested in.
\end_layout

\begin_layout Subsubsection
Where does the truth lie in the distribution of the model?
\end_layout

\begin_layout Standard
If we know the true abundance in our simulation (
\begin_inset Formula $N_{\text{truth}}$
\end_inset

), then we can derive a useful diagnostic measure by asking at what quantile
 does 
\begin_inset Formula $N_{\text{truth}}$
\end_inset

 lie in the distribution implied by the model (i.e., find 
\begin_inset Formula $\mathbb{P}[N_{\text{truth}}\leq\hat{N}]$
\end_inset

).
 Here we assume log-normally distributed 
\begin_inset Formula $\hat{N}$
\end_inset

, so use the usual formulae to find the resulting quantiles.
 This summary statistic gives some idea of both bias and variance.
\end_layout

\begin_layout Standard
Obtaining the quantile for each simulation, if the distribution of the statistic
 is skewed to either end then we can infer under or over estimation of abundance
 for a particular estimator.
 A flat distribution shows good performance, whereas a "dome" in the middle
 indicates a conservative estimate in the sense that confidence intervals
 are slightly too wide.
 This more conservative behaviour seems desirable, since we probably have
 no accounted for all of the sources of uncertainty in our model.
 An example of plots of this statistic is given in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:self-confidence"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<self-confidence, fig.width=9, fig.height=3, echo=FALSE, message=FALSE, warning=F
ALSE>>=
\end_layout

\begin_layout Plain Layout

# an example in self-confidence
\end_layout

\begin_layout Plain Layout

# quick plot to show what those plots should look like in different 
\end_layout

\begin_layout Plain Layout

# situations
\end_layout

\begin_layout Plain Layout

library(ggplot2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# number of reps 
\end_layout

\begin_layout Plain Layout

n <- 1000
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# when things go "right" -- flat distribution 
\end_layout

\begin_layout Plain Layout

dat <- data.frame(scenario = "ok", quantile = runif(n))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# spike on the left => negative bias
\end_layout

\begin_layout Plain Layout

nb <- rexp(2*n, 2) 
\end_layout

\begin_layout Plain Layout

nb <- nb[nb<1 & nb >0] 
\end_layout

\begin_layout Plain Layout

nb <- nb[1:1000] 
\end_layout

\begin_layout Plain Layout

dat <- rbind(dat, data.frame(scenario = "-ve bias", quantile = nb))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# spike on the right => positive bias 
\end_layout

\begin_layout Plain Layout

nb <- 1-rexp(2*n, 2) 
\end_layout

\begin_layout Plain Layout

nb <- nb[nb<1 & nb >0] 
\end_layout

\begin_layout Plain Layout

nb <- nb[1:1000] 
\end_layout

\begin_layout Plain Layout

dat <- rbind(dat, data.frame(scenario = "+ve bias", quantile = nb))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# what we'd like to see 
\end_layout

\begin_layout Plain Layout

nb <- rnorm(2*n, mean=0.5, sd=0.1) 
\end_layout

\begin_layout Plain Layout

nb <- nb[nb<1 & nb >0] 
\end_layout

\begin_layout Plain Layout

nb <- nb[1:1000] 
\end_layout

\begin_layout Plain Layout

dat <- rbind(dat, data.frame(scenario = "Over confident", quantile = nb))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# what we'd like to see 
\end_layout

\begin_layout Plain Layout

nb <- rnorm(2*n, mean=0.5, sd=0.35) 
\end_layout

\begin_layout Plain Layout

nb <- nb[nb<1 & nb >0] 
\end_layout

\begin_layout Plain Layout

nb <- nb[1:1000] 
\end_layout

\begin_layout Plain Layout

dat <- rbind(dat, data.frame(scenario = "Conservative", quantile = nb))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p <- ggplot(dat) +
\end_layout

\begin_layout Plain Layout

      geom_histogram(aes(quantile), binwidth=0.05)+
\end_layout

\begin_layout Plain Layout

      scale_x_continuous(limits=c(0,1))+
\end_layout

\begin_layout Plain Layout

      facet_wrap(~scenario, nrow=1) +
\end_layout

\begin_layout Plain Layout

      geom_vline(xintercept=0.5) +
\end_layout

\begin_layout Plain Layout

      labs(x="Quantile", y="Count") +
\end_layout

\begin_layout Plain Layout

      theme_minimal()
\end_layout

\begin_layout Plain Layout

print(p)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Illustration of the 
\begin_inset Quotes eld
\end_inset

self-confidence
\begin_inset Quotes erd
\end_inset

 measure.
 From left to right: 
\begin_inset Quotes eld
\end_inset

ok
\begin_inset Quotes erd
\end_inset

 denotes shows a plot with flat quantile distribution (no problems), 
\begin_inset Quotes eld
\end_inset

-ve bias
\begin_inset Quotes erd
\end_inset

 shows a large spike at zero indicating negative bias, 
\begin_inset Quotes eld
\end_inset

+ve bias
\begin_inset Quotes erd
\end_inset

 shows the spike at 1 indicating positive bias, 
\begin_inset Quotes eld
\end_inset

conservative
\begin_inset Quotes erd
\end_inset

 shows behaviour where the confidence intervals are slightly too wide, which
 we might prefer (see main text).
\begin_inset CommandInset label
LatexCommand label
name "fig:self-confidence"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Results
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-data-format, echo=FALSE, message=FALSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(plyr)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# one for each distribution/detectability
\end_layout

\begin_layout Plain Layout

f_names <- list.files(path="../simulation_study/",  pattern="*
\backslash

\backslash
.RData", 
\end_layout

\begin_layout Plain Layout

                      full.names=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# lookup for model names to short descriptions
\end_layout

\begin_layout Plain Layout

model_name_lookup <- c("HT",
\end_layout

\begin_layout Plain Layout

                       "HTcovar",
\end_layout

\begin_layout Plain Layout

                       "HTstrat",
\end_layout

\begin_layout Plain Layout

                       "HTstratcovar",
\end_layout

\begin_layout Plain Layout

                       "Duchon",
\end_layout

\begin_layout Plain Layout

                       "TPTE",
\end_layout

\begin_layout Plain Layout

                       "TP",
\end_layout

\begin_layout Plain Layout

                       "TPSH",
\end_layout

\begin_layout Plain Layout

                       "TPR",
\end_layout

\begin_layout Plain Layout

                       "TPTER")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

names(model_name_lookup) <- c("HT",
\end_layout

\begin_layout Plain Layout

                              "HT_cov",
\end_layout

\begin_layout Plain Layout

                              "HT_strat",
\end_layout

\begin_layout Plain Layout

                              "HT_strat_cov",
\end_layout

\begin_layout Plain Layout

                              "m_xy_ds",
\end_layout

\begin_layout Plain Layout

                              "m_xy_te",
\end_layout

\begin_layout Plain Layout

                              "m_xy_tp",
\end_layout

\begin_layout Plain Layout

                              "m_xy_ts",
\end_layout

\begin_layout Plain Layout

                              "m_xyr_tp",
\end_layout

\begin_layout Plain Layout

                              "m_xyr_te")
\end_layout

\begin_layout Plain Layout

model_name_lookup <- factor(model_name_lookup, levels=c("HT", "HTcovar",
 "HTstrat",
\end_layout

\begin_layout Plain Layout

                                                        "HTstratcovar",
 "Duchon", "TPTE",
\end_layout

\begin_layout Plain Layout

                                                        "TP", "TPSH", "TPR",
 "TPTER"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

huge_res <- c()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# now loop over the files
\end_layout

\begin_layout Plain Layout

for(i in seq_along(f_names)){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  load(f_names[i])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # print the name of this scenario as the header
\end_layout

\begin_layout Plain Layout

  f_names[i] <- sub("../simulation_study//", "", f_names[i], fixed=TRUE)
\end_layout

\begin_layout Plain Layout

  f_names[i] <- sub(".RData", "", f_names[i])
\end_layout

\begin_layout Plain Layout

  big_res$scenario <- f_names[i]
\end_layout

\begin_layout Plain Layout

  big_res$model <- as.character(big_res$model)
\end_layout

\begin_layout Plain Layout

  big_res$model <- model_name_lookup[big_res$model]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## WARNING: magic numbers below!!
\end_layout

\begin_layout Plain Layout

  # bias boxplot
\end_layout

\begin_layout Plain Layout

  big_res$bias <- big_res$N-500
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # separate out the scenario definition
\end_layout

\begin_layout Plain Layout

  big_res$density <- sub("([a-z]+)-[a-z]+-[a-z]+", "
\backslash

\backslash
1", big_res$scenario[1])
\end_layout

\begin_layout Plain Layout

  big_res$design <- sub("[a-z]+-([a-z]+)-[a-z]+", "
\backslash

\backslash
1", big_res$scenario[1])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(big_res$design == "tb"){
\end_layout

\begin_layout Plain Layout

	big_res$design <- "twozigzag"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(!grepl("covar", big_res$scenario[1])){
\end_layout

\begin_layout Plain Layout

    big_res$df <- sub("[a-z]+-[a-z]+-([a-z]+)", "
\backslash

\backslash
1", big_res$scenario[1])
\end_layout

\begin_layout Plain Layout

    big_res$covar <- FALSE
\end_layout

\begin_layout Plain Layout

  }else{
\end_layout

\begin_layout Plain Layout

    big_res$covar <- TRUE
\end_layout

\begin_layout Plain Layout

	big_res$df <- "covar"
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  huge_res <- rbind(huge_res, big_res)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We experimented with possible combinations of simulation scenarios based
 on the models about.
 In each scenario, we tested all of the modelling options listed above and
 recorded the metrics from the previous section.
 The density surfaces described in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Density-surfaces"

\end_inset

 only describe the 
\shape italic
relative
\shape default
 density of the population in question.
 We (arbitrarily) fixed the total population size to be 200 individuals
 for each simulation.
\end_layout

\begin_layout Standard
Note that the aim here is not to show 
\shape italic
which
\shape default
 spatial model is best out of those presented here, it is to show that there
 are large differences between the HT estimators and the spatial models.
 Differences between the spatial models can be attributed to the model formulati
on process, for example in the cases where the gradient was simply right-left,
 left-right or flat, fitting a bivariate spatial model will likely not perform
 particularly well as it is too flexible.
 Additionally, none of the models underwent model checking in the usual
 way 
\begin_inset CommandInset citation
LatexCommand citep
before "e.g.,"
key "Miller:2013fq,Winiarski:2014bc"

\end_inset

, so the spatial models represent the 
\begin_inset Quotes eld
\end_inset

dumbest possible
\begin_inset Quotes erd
\end_inset

 spatial model, without any thought to checking or calibration.
\end_layout

\begin_layout Standard
We can now look at the more interesting subsets of the results.
 Full results of all models run are provided in Appendix 2.
\end_layout

\begin_layout Section
Discussion 
\end_layout

\begin_layout Standard
(of things that are still negotiable to include post-Bled :)
\end_layout

\begin_layout Itemize
note that we only need consider these simple gradients not multiples, as
 we can consider each as a stratified version of a 
\begin_inset Quotes eld
\end_inset

multiple ripple
\begin_inset Quotes erd
\end_inset

 setup
\end_layout

\begin_layout Part*
Appendices
\end_layout

\begin_layout Section*
Appendix 1 - Data format for 
\family typewriter
Distance
\family default
 and 
\family typewriter
dsm
\end_layout

\begin_layout Standard
In this appendix we describe the data format required for the two packages
 used above.
 The text below is adapted from their respective manuals.
\end_layout

\begin_layout Subsection*

\family typewriter
Distance
\end_layout

\begin_layout Standard
A single 
\family typewriter
data.frame 
\family default
should be provided to
\family typewriter
 Distance
\family default
 to fit a detection function, or to estimate abundance using the HT estimator.
 To simply fit a detection function we require the following columns in
 our data:
\end_layout

\begin_layout Itemize

\family typewriter
distance
\family default
 observed perpendicular distance to observation from the line
\end_layout

\begin_layout Itemize

\family typewriter
object
\family default
 an unique identifier for the observation
\end_layout

\begin_layout Standard
If one wishes to estimate abundance, the following columns are also required:
\end_layout

\begin_layout Itemize

\family typewriter
Sample.Label
\family default
 Identifier for the sample (transect) 
\end_layout

\begin_layout Itemize

\family typewriter
Effort
\family default
 effort for this transect (transect length) 
\end_layout

\begin_layout Itemize

\family typewriter
Region.Label
\family default
 label for a given stratum
\end_layout

\begin_layout Itemize

\family typewriter
Area
\family default
 area of the strata
\end_layout

\begin_layout Standard
Each row corresponds to one observation.
 In some cases a given transect or even stratum may contain zero observations.
 In this case the transect(s) are still included, along with their effort,
 but their corresponding 
\family typewriter
object
\family default
 and 
\family typewriter
distance
\family default
 fields are set to 
\begin_inset Quotes eld
\end_inset

not available
\begin_inset Quotes erd
\end_inset

 (in R 
\begin_inset Quotes eld
\end_inset


\family typewriter
NA
\family default

\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Subsection*

\family typewriter
dsm
\end_layout

\begin_layout Standard
Two 
\family typewriter
data.frame
\family default
s must be provided to 
\family typewriter
dsm
\family default
.
 They are referred to as 
\family typewriter
observation.data
\family default
 and 
\family typewriter
segment.data
\family default
.
 The 
\family typewriter
segment.data
\family default
 table has the sample identifiers which define the segments, the corresponding
 effort (line length) expended and the environmental covariates that will
 be used to model abundance/density.
 
\family typewriter
observation.data
\family default
 provides a link table between the observations used in the detection function
 and the samples (segments), so that we can aggregate the observations to
 the segments (i.e.
 
\family typewriter
observation.data
\family default
 is a "look-up table" between the observations and the segments).
\end_layout

\begin_layout Subsubsection*

\family typewriter
observation.data
\end_layout

\begin_layout Standard
The observation 
\family typewriter
data.frame
\family default
 must have (at least) the following columns: 
\end_layout

\begin_layout Itemize

\family typewriter
object
\family default
 unique object identifier
\end_layout

\begin_layout Itemize

\family typewriter
Sample.Label
\family default
 the identifier for the segment that the observation occurred in 
\end_layout

\begin_layout Itemize

\family typewriter
size
\family default
 the size of each observed group (e.g 1 if all animals occurred individually)
 
\end_layout

\begin_layout Itemize

\family typewriter
distance
\family default
 distance to observation
\end_layout

\begin_layout Standard
One can often also use 
\family typewriter
observation.data
\family default
 to fit a detection function (so additional columns for detection function
 covariates are allowed in this table).
\end_layout

\begin_layout Subsubsection*

\family typewriter
segment.data
\end_layout

\begin_layout Standard
The segment 
\family typewriter
data.frame
\family default
 must have (at least) the following columns:
\end_layout

\begin_layout Itemize

\family typewriter
Effort
\family default
 the effort (in terms of length of the segment) 
\end_layout

\begin_layout Itemize

\family typewriter
Sample.Label
\family default
 identifier for the segment (unique!) 
\end_layout

\begin_layout Itemize
??? environmental covariates, for example: location (projected latitude
 and longitude), and other relevant covariates (sea surface temperature,
 bathymetry etc).
 
\end_layout

\begin_layout Section*
Appendix 2 - Full simulation results
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-funcs, echo=FALSE, message=FALSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

library(ggplot2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# plot quantiles
\end_layout

\begin_layout Plain Layout

plot_quantile <- function(dat, covar){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  #ndat <- ddply(dat, .(df,design,model),  summarize, thisn=length(df))
\end_layout

\begin_layout Plain Layout

  #ndat$df<-NULL
\end_layout

\begin_layout Plain Layout

  #ndat <- unique(ndat)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  p <- ggplot(dat)+
\end_layout

\begin_layout Plain Layout

        geom_histogram(aes(quantile))+
\end_layout

\begin_layout Plain Layout

        geom_vline(xintercept=0.5) +
\end_layout

\begin_layout Plain Layout

        #geom_text(aes(x=0.8, y=60, label=thisn), data=ndat) +
\end_layout

\begin_layout Plain Layout

        theme_minimal()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if(covar){
\end_layout

\begin_layout Plain Layout

    p <- p + facet_grid(model~design,
\end_layout

\begin_layout Plain Layout

                        labeller=function(labels, multi_line=FALSE){
\end_layout

\begin_layout Plain Layout

                         label_value(labels, multi_line)
\end_layout

\begin_layout Plain Layout

                        })
\end_layout

\begin_layout Plain Layout

  }else{
\end_layout

\begin_layout Plain Layout

    p <- p + facet_wrap(model~design+df, ncol=3,
\end_layout

\begin_layout Plain Layout

                        labeller=function(labels, multi_line=FALSE){
\end_layout

\begin_layout Plain Layout

                         label_value(labels, multi_line)
\end_layout

\begin_layout Plain Layout

                        })
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  print(p)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# bias plotter
\end_layout

\begin_layout Plain Layout

plot_bias <- function(dat, covar){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  p <- ggplot(dat)+
\end_layout

\begin_layout Plain Layout

    geom_boxplot(aes(model, bias), outlier.size = 0.75) +
\end_layout

\begin_layout Plain Layout

    labs(y="Bias", x="Model") +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(ylim=c(-500, 500)) +
\end_layout

\begin_layout Plain Layout

    theme_minimal() +
\end_layout

\begin_layout Plain Layout

    facet_grid(design~df,
\end_layout

\begin_layout Plain Layout

               labeller=function(labels, multi_line=FALSE){
\end_layout

\begin_layout Plain Layout

                          label_value(labels, multi_line)
\end_layout

\begin_layout Plain Layout

                        }) +
\end_layout

\begin_layout Plain Layout

    geom_hline(aes(yintercept=0), colour="red") +
\end_layout

\begin_layout Plain Layout

    theme(axis.text.x = element_text(angle=90, hjust=1))
\end_layout

\begin_layout Plain Layout

  print(p)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:biasf"

\end_inset

 shows the bias in abundance estimates.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-bias-f, fig.width=9, fig.height=9, echo=FALSE, message=FALSE,
 warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_f <- huge_res[huge_res$density=="f",]
\end_layout

\begin_layout Plain Layout

plot_bias(huge_res_f, FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bias in abundance for each of the models per simulation scenario for the
 flat density.
\begin_inset CommandInset label
LatexCommand label
name "fig:biasf"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-bias-lr, fig.width=9, fig.height=9, echo=FALSE, message=FALSE,
 warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_lr <- huge_res[huge_res$density=="lr",]
\end_layout

\begin_layout Plain Layout

plot_bias(huge_res_lr, FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bias in abundance for each of the models per simulation scenario for the
 left-right gradient density.
\begin_inset CommandInset label
LatexCommand label
name "fig:biaslr"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-bias-rl, fig.width=9, fig.height=9, echo=FALSE, message=FALSE,
 warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_rl <- huge_res[huge_res$density=="rl",]
\end_layout

\begin_layout Plain Layout

plot_bias(huge_res_rl, FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bias in abundance for each of the models per simulation scenario for the
 right-left gradient density.
\begin_inset CommandInset label
LatexCommand label
name "fig:biasrl"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-bias-diag, fig.width=9, fig.height=9, echo=FALSE, message=FALSE,
 warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_diag <- huge_res[huge_res$density=="diag",]
\end_layout

\begin_layout Plain Layout

plot_bias(huge_res_diag, FALSE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Bias in abundance for each of the models per simulation scenario for the
 diagonal gradient density.
\begin_inset CommandInset label
LatexCommand label
name "fig:biasdiag"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-selfconfidence-f, fig.width=9, fig.height=9, echo=FALSE, message=FA
LSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_f <- huge_res[huge_res$density=="f",]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

plot_quantile(huge_res_f, TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Histograms of the 
\begin_inset Quotes eld
\end_inset

self-confidence
\begin_inset Quotes erd
\end_inset

 measure for each model for the flat density surface.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-selfconfidence-lr, fig.width=9, fig.height=9, echo=FALSE, message=F
ALSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_lr <- huge_res[huge_res$density=="lr",]
\end_layout

\begin_layout Plain Layout

plot_quantile(huge_res_lr, TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Histograms of the 
\begin_inset Quotes eld
\end_inset

self-confidence
\begin_inset Quotes erd
\end_inset

 measure for each model for the left-right density surface.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-selfconfidence-rl, fig.width=9, fig.height=9, echo=FALSE, message=F
ALSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_rl <- huge_res[huge_res$density=="rl",]
\end_layout

\begin_layout Plain Layout

plot_quantile(huge_res_rl, TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Histograms of the 
\begin_inset Quotes eld
\end_inset

self-confidence
\begin_inset Quotes erd
\end_inset

 measure for each model for the right-left density surface.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-results-selfconfidence-diag, fig.width=3, fig.height=9, echo=FALSE,
 message=FALSE, warning=FALSE>>=
\end_layout

\begin_layout Plain Layout

huge_res_diag <- huge_res[huge_res$density=="diag",]
\end_layout

\begin_layout Plain Layout

plot_quantile(huge_res_diag, TRUE)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Histograms of the 
\begin_inset Quotes eld
\end_inset

self-confidence
\begin_inset Quotes erd
\end_inset

 measure for each model for the diagonal density surface.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "full,this"
options "default"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
printbibliography
\end_layout

\end_inset


\end_layout

\end_body
\end_document
